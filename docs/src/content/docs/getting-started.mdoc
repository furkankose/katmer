---
title: Getting Started
sidebar:
   order: 0
---

Katmer is a lightweight, scriptable automation engine for running tasks on machines, either **locally** or
**over SSH**. At its core, Katmer is a reliable command executor with structure: it knows *where* to run commands,
*how* to connect, and *how* to evaluate templates, conditions, and results consistently.

Unlike tools such as Ansible, Katmer is designed as a **single self-contained executable**. There is no daemon,
no agent, and no runtime dependency on Python or system packages. You download one binary and run it.

Katmer is also usable as a **library**. Internally, the CLI is just a thin wrapper around the same APIs you can
embed in your own Bun-based tooling. This makes it suitable not only for ad-hoc automation and CI/CD
jobs, but also for building higher-level orchestration systems.

Today, Katmer is intentionally focused on **small to mid-sized infrastructures**. It prioritizes clarity,
predictability, and debuggability over large-scale fleet abstractions.

At a high level, Katmer works by resolving targets, creating providers (SSH or local), preparing an
execution context, and running one module per task. Each module returns a structured result that Katmer
can inspect, chain, or retry.

## Installation

Katmer is distributed as a single executable.

You can download the latest release directly from GitHub:

[https://github.com/katmer-io/katmer/releases](https://github.com/katmer-io/katmer/releases)

Choose the binary that matches your operating system and architecture, place it somewhere in your `PATH`,
and make it executable if necessary.

For example on Linux or macOS:

```sh
chmod +x katmer
mv katmer /usr/local/bin/katmer
```

No additional dependencies are required.

## Core Concepts

Katmer revolves around a small number of concepts that compose cleanly.

**Targets** describe *where* tasks run. A target can represent a remote host accessed over SSH or the local
machine itself. Targets can be defined in a separate inventory file or inline inside the same task file for
fully self-contained scripts. Detailed target configuration is covered in the Targets guide.

**Tasks** describe *what* should happen. A task always runs against one or more targets, has a human-readable
name, and executes exactly one module. Tasks can optionally include conditions, loops, variable registration,
or privilege escalation.

**Modules** are the units of work and they perform concrete actions. Each module exposes a clear interface and
returns a consistent result structure.

**Control flow** allows you to add logic around tasks. You can conditionally run tasks, iterate over data, or chain results between tasks. These features are documented in detail in the Variables, Conditionals, and Loops guides.

This page intentionally keeps these descriptions brief. Each concept has its own dedicated guide that goes deeper.

## Quick Start

The fastest way to get started is to write a single YAML file that contains both **targets** and **tasks**.

Create a file called `deploy.yaml`:

```yaml
targets:
  production:
    settings:
      connection: ssh
      port: 22
    variables:
      app_dir: /opt/myapp
    hosts:
      web-01:
        hostname: 10.0.0.11
        username: deploy
        private_key: ~/.ssh/id_rsa

tasks:
- name: Upload application archive
  targets: production
  copy:
    src: "./dist/myapp.tar.gz"
    dest: "/opt/myapp/myapp.tar.gz"

- name: Extract application
  targets: production
  script: |
    mkdir -p "{{ app_dir }}"
    tar -xzf /opt/myapp/myapp.tar.gz -C "{{ app_dir }}"

- name: Restart service
  targets: production
  become: true
  script: "systemctl restart myapp"
```

In this example, the targets are defined inline, making the file completely portable. These tasks uses `copy`
and `script` modules to upload and execute a script respectively.

To execute the file, run:

```sh
katmer run deploy.yaml
```

Katmer will resolve the targets, connect over SSH, upload the archive, extract it, and restart the service.
Each task runs independently and reports whether it changed anything or failed.

This same pattern works for local execution as well:

```yaml
tasks:
- name: Check disk usage locally
  targets: local
  script: "df -h"
```

From here, you can gradually introduce more advanced features like variables, loops, conditionals,
or package management, all while keeping your automation readable and explicit.

That is the core Katmer workflow: describe targets, define tasks, run modules, and let Katmer handle the rest.
